# Stubs for future.utils (Python 3)
#
# NOTE: This dynamically typed stub was automatically generated by stubgen.

import sys
import typing
import types
from typing import (
    TypeVar, Iterator, Iterable, NoReturn, overload, Container,
    Sequence, MutableSequence, Mapping, MutableMapping, Tuple, List, Any, Dict, Callable, Generic,
    Set, AbstractSet, FrozenSet, MutableSet, Sized, Reversible, SupportsInt, SupportsFloat, SupportsAbs,
    SupportsComplex, IO, BinaryIO, Union,
    ItemsView, KeysView, ValuesView, ByteString, Optional, AnyStr, Type, Text,
    Protocol,
)

_T = TypeVar('_T')
_T_co = TypeVar('_T_co', covariant=True)
_KT = TypeVar('_KT')
_VT = TypeVar('_VT')
_S = TypeVar('_S')
_T1 = TypeVar('_T1')
_T2 = TypeVar('_T2')
_T3 = TypeVar('_T3')
_T4 = TypeVar('_T4')
_T5 = TypeVar('_T5')
_TT = TypeVar('_TT', bound='type')

PY3: bool
PY2: bool
PY26: bool
PYPY: bool

def python_2_unicode_compatible(cls: Type) -> bool: ...
def with_metaclass(meta: type, *bases: type) -> type: ...

if sys.version_info[0] >= 3:
    def bchr(s: Any): ...
    def bstr(s: Any): ...
    def bord(s: Any): ...
    def tobytes(s: Any) -> bytes: ...

    string_types = str,
    integer_types = int,
    class_types = type,
    text_type = str
    binary_type = bytes

else:
    def bchr(s: Any): ...
    def bstr(s: Any): ...
    def bord(s: Any): ...
    def tobytes(s: Any) -> bytes: ...

    string_types = str, unicode
    integer_types = (int, long)
    class_types = (type, types.ClassType)
    text_type = unicode
    binary_type = str

def native_str_to_bytes(s: native_str, encoding: str = ...) -> native_bytes: ...
def bytes_to_native_str(b: native_bytes, encoding: str = ...) -> native_str: ...
def text_to_native_str(t: Union[native_bytes, native_str], encoding: Optional[Any] = ...) -> native_str: ...


if sys.version_info[0] >= 3:
    # list-producing versions of the major Python iterating functions
    def lrange(__x: int, __y: int = ..., __step: int = ...) -> List[int]: ...

    @overload
    def lzip(__iter1: Iterable[_T1]) -> List[Tuple[_T1]]: ...
    @overload
    def lzip(__iter1: Iterable[_T1],
             __iter2: Iterable[_T2]) -> List[Tuple[_T1, _T2]]: ...
    @overload
    def lzip(__iter1: Iterable[_T1], __iter2: Iterable[_T2],
             __iter3: Iterable[_T3]) -> List[Tuple[_T1, _T2, _T3]]: ...
    @overload
    def lzip(__iter1: Iterable[_T1], __iter2: Iterable[_T2], __iter3: Iterable[_T3],
             __iter4: Iterable[_T4]) -> List[Tuple[_T1, _T2, _T3, _T4]]: ...
    @overload
    def lzip(__iter1: Iterable[_T1], __iter2: Iterable[_T2], __iter3: Iterable[_T3],
             __iter4: Iterable[_T4], __iter5: Iterable[_T5]) -> List[Tuple[_T1, _T2, _T3, _T4, _T5]]: ...
    @overload
    def lzip(__iter1: Iterable[Any], __iter2: Iterable[Any], __iter3: Iterable[Any],
             __iter4: Iterable[Any], __iter5: Iterable[Any], __iter6: Iterable[Any],
             *iterables: Iterable[Any]) -> List[Tuple[Any, ...]]: ...

    @overload
    def lfilter(__function: Callable[[AnyStr], Any],  # type: ignore
               __iterable: AnyStr) -> AnyStr: ...
    @overload
    def lfilter(__function: None,  # type: ignore
               __iterable: Tuple[Optional[_T], ...]) -> Tuple[_T, ...]: ...
    @overload
    def lfilter(__function: Callable[[_T], Any],  # type: ignore
               __iterable: Tuple[_T, ...]) -> Tuple[_T, ...]: ...
    @overload
    def lfilter(__function: None,
               __iterable: Iterable[Optional[_T]]) -> List[_T]: ...
    @overload
    def lfilter(__function: Callable[[_T], Any],
               __iterable: Iterable[_T]) -> List[_T]: ...

    @overload
    def lmap(__func: None, __iter1: Iterable[_T1]) -> List[_T1]: ...
    @overload
    def lmap(__func: None,
            __iter1: Iterable[_T1],
            __iter2: Iterable[_T2]) -> List[Tuple[_T1, _T2]]: ...
    @overload
    def lmap(__func: None,
            __iter1: Iterable[_T1],
            __iter2: Iterable[_T2],
            __iter3: Iterable[_T3]) -> List[Tuple[_T1, _T2, _T3]]: ...
    @overload
    def lmap(__func: None,
            __iter1: Iterable[_T1],
            __iter2: Iterable[_T2],
            __iter3: Iterable[_T3],
            __iter4: Iterable[_T4]) -> List[Tuple[_T1, _T2, _T3, _T4]]: ...
    @overload
    def lmap(__func: None,
            __iter1: Iterable[_T1],
            __iter2: Iterable[_T2],
            __iter3: Iterable[_T3],
            __iter4: Iterable[_T4],
            __iter5: Iterable[_T5]) -> List[Tuple[_T1, _T2, _T3, _T4, _T5]]: ...
    @overload
    def lmap(__func: None,
            __iter1: Iterable[Any],
            __iter2: Iterable[Any],
            __iter3: Iterable[Any],
            __iter4: Iterable[Any],
            __iter5: Iterable[Any],
            __iter6: Iterable[Any],
            *iterables: Iterable[Any]) -> List[Tuple[Any, ...]]: ...
    @overload
    def lmap(__func: Callable[[_T1], _S], __iter1: Iterable[_T1]) -> List[_S]: ...
    @overload
    def lmap(__func: Callable[[_T1, _T2], _S],
            __iter1: Iterable[_T1],
            __iter2: Iterable[_T2]) -> List[_S]: ...
    @overload
    def lmap(__func: Callable[[_T1, _T2, _T3], _S],
            __iter1: Iterable[_T1],
            __iter2: Iterable[_T2],
            __iter3: Iterable[_T3]) -> List[_S]: ...
    @overload
    def lmap(__func: Callable[[_T1, _T2, _T3, _T4], _S],
            __iter1: Iterable[_T1],
            __iter2: Iterable[_T2],
            __iter3: Iterable[_T3],
            __iter4: Iterable[_T4]) -> List[_S]: ...
    @overload
    def lmap(__func: Callable[[_T1, _T2, _T3, _T4, _T5], _S],
            __iter1: Iterable[_T1],
            __iter2: Iterable[_T2],
            __iter3: Iterable[_T3],
            __iter4: Iterable[_T4],
            __iter5: Iterable[_T5]) -> List[_S]: ...
    @overload
    def lmap(__func: Callable[..., _S],
            __iter1: Iterable[Any],
            __iter2: Iterable[Any],
            __iter3: Iterable[Any],
            __iter4: Iterable[Any],
            __iter5: Iterable[Any],
            __iter6: Iterable[Any],
            *iterables: Iterable[Any]) -> List[_S]: ...


else:
    import __builtin__
    # Python 2-builtin ranges produce lists
    lrange = __builtin__.range
    lzip = __builtin__.zip
    lmap = __builtin__.map
    lfilter = __builtin__.filter

def isidentifier(s: Text, dotted: bool = ...) -> bool: ...

def viewitems(d: Mapping[_KT, _VT]) -> ItemsView[_KT, _VT]: ...
def viewkeys(d: Mapping[_KT, _VT]) -> KeysView[_KT]: ...
def viewvalues(d: Mapping[_KT, _VT]) -> ValuesView[_VT]: ...

def iteritems(d: Mapping[_KT, _VT]) -> typing.Iterator[Tuple[_KT, _VT]]: ...
def iterkeys(d: Mapping[_KT, _VT]) -> typing.Iterator[_KT]: ...
def itervalues(d: Mapping[_KT, _VT]) -> typing.Iterator[_VT]: ...

def bind_method(cls: type, name: str, func: Callable) -> None: ...
def getexception(): ...

def raise_(tp: Optional[Type[BaseException]], value: Optional[BaseException],
           tb: Optional[types.TracebackType] = ...) -> NoReturn: ...
reraise = raise_
def raise_from(exc: Union[BaseException, Type[BaseException]], cause: Optional[BaseException]) -> NoReturn: ...
def raise_with_traceback(exc: Union[BaseException, Type[BaseException]], traceback: Any = ...) -> None: ...

def implements_iterator(cls: type) -> bool: ...

get_next: Any

def encode_filename(filename: Any): ...
def is_new_style(cls: Type) -> bool: ...

native_str = str
native_bytes = bytes

def istext(obj: Any) -> bool: ...
def isbytes(obj: Any) -> bool: ...
def isnewbytes(obj: Any) -> bool: ...
def isint(obj: Any) -> bool: ...
def native(obj: Any): ...

def exec_(_code_: Union[Text, types.CodeType], _globs_: Dict[str, Any] = ..., _locs_: Dict[str, Any] = ...): ...

def old_div(a: Any, b: Any): ...
def as_native_str(encoding: str = ...): ...

def listvalues(d: Any): ...
def listitems(d: Any): ...

def ensure_new_type(obj: Any): ...
